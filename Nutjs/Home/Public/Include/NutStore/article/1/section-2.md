# 整理分支保持干净 #

我们常说某个分支是主分支，主分支应该保持“干净”。那么什么是所谓的干净？如果已经不小心弄乱了如何将它变为干净？这都是本节要讨论的内容。

## 分支上的提交（commit） ##

对于commit大家一定不陌生，如下面的master分支上就有2个commit

    * 1c70c4b - (HEAD -> master)完成了会员登录功能
    |
    * e5e896b - 创建项目

假设我们还有dev分支，用来辅助master分支。假设他们的结构是这样的

    * 1c70c4b - (HEAD -> master)完成了会员登录功能
    |\
    | \
    |  * 4b8ad32 - (dev) 修正Bug
    |  |
    |  * bd1a340 - 写完了会员登录的后台
    |  |
    |  * c7d31a2 - 写完了会员登录的页面
    | / 
    |/
    * e5e896b - 创建项目

那么这时候master分支和dev分支上各有多少个commit呢？

答案是master分支5个commit，dev分支4个commit

- master：e5e896b c7d31a2 bd1a340 4b8ad32 1c70c4b
- dev：e5e896b c7d31a2 bd1a340 4b8ad32

其中dev分支比较好理解，我们在最开始的commit（e5e896b）上创建的dev分支，然后在dev分支上进行了3次commit，1+3自然是4个。因为最终的1c70c4b是合并进master的，所以不算在dev分支上。

而master分支可能就比较难以理解，看上面的结构貌似是有2个commit的样子。其实这时候我们只要删除dev分支一切就很清晰了

    git branch -d -D dev

那么结构就变成了这样

    * 1c70c4b - (HEAD -> master)完成了会员登录功能
    |
    * 4b8ad32 - 修正Bug
    |
    * bd1a340 - 写完了会员登录的后台
    |
    * c7d31a2 - 写完了会员登录的页面
    |
    * e5e896b - 创建项目

这样就很明显了，原来dev分支上的3个commit也属于master分支。

为什么会这样的？其实原理也比较好理解，因为master分支上有一个commit（1c70c4b）是由dev分支上的3个commit（c7d31a2 bd1a340 4b8ad32）合并来的，所以如果想保留合并来的commit节点，就必须要保留原始的commit。

简单来说就是，**想留成品必须要保留原材料**。

再看下面的例子，结构如下

    *   882e00a - (HEAD -> master)完成修改资料的功能
    |\
    | * c7d31a2 - (change_inf)写完了修改资料的后台
    | |
    | * 2fd639f - 写完了修改资料的页面
    * | 3ac33f6 - 完成修改密码的功能
    |/
    * 4e40742 - 构架目录
    |
    * 34309d9 - 创建项目

那么其中的change_inf分支有几个commit，master分支有多少个commit？

答案是master分支有6个commit，也就是全部，如果你删除了change_inf分支，结构会是这样

    *   882e00a - (HEAD -> master)完成修改资料的功能
    |\
    | * c7d31a2 - 写完了修改资料的后台
    | |
    | * 2fd639f - 写完了修改资料的页面
    * | 3ac33f6 - 完成修改密码的功能
    |/
    * 4e40742 - 构架目录
    |
    * 34309d9 - 创建项目

Git依旧会保留完整的合并痕迹，这也是为什么我们要将**功能分支合并进master分支后删除这个功能分支**的原因，因为你尽管删除了这个分支，Git还是会帮你保留完整的合并信息来帮助后来的开发者阅读项目历史。

那么change_inf分支就有4个commit了，如果删除master分支结构会是这样


    * c7d31a2 - (HEAD -> change_inf)写完了修改资料的后台
    | 
    * 2fd639f - 写完了修改资料的页面
    | 
    * 4e40742 - 构架目录
    |
    * 34309d9 - 创建项目

Git会去掉与现有的分支无关的commit节点，比如3ac33f6（完成修改密码的功能）节点就对于change_inf分支毫无意义，就不会显示在这里。

所以，我们得出一般情况下的结论：**master分支上的commit将会是最多的**，并且master分支有一个重要的特性就是**最新的一次commit总是稳定的**。

下面的结构能说明这个特性：

      * 2fd639f - (HEAD -> change_inf)写完了修改资料的页面
    * | 3ac33f6 - (master)完成修改密码的功能
    |/
    * 4e40742 - 构架目录
    |
    * 34309d9 - 创建项目

master分支最新的一次commit（3ac33f6）是稳定的版本，而整个项目最新的commit（2fd639f）则不是稳定的（因为没有完成修改资料的后台部分，如果贸然上线会导致用户的困惑）。

## 为什么要打标签（tag） ##

如果项目遇到严重bug需要回滚怎么办？比如下面的结构

    *   882e00a - (HEAD -> master)完成修改资料的功能
    |\
    | * c7d31a2 - (change_inf)写完了修改资料的后台
    | |
    | * 2fd639f - 写完了修改资料的页面
    | | 
    |/
    * eff7c11 - 完成修改密码的功能
    | 
    * 4e40742 - 构架目录
    |
    * 34309d9 - 创建项目

我们发现修改资料功能有严重的bug，需要返回上一个稳定的版本。

如果按照时间来排序，上一个版本是change_inf上的c7d31a2（写完了修改资料的后台），并不是稳定的版本。不过我们通过观察目录，很容易发现上一个稳定的版本是eff7c11（完成修改密码的功能），这时候我们就可以愉快的“滚过去”了。

但是有时候发现上一个稳定版本并不是那么容易，比如我们遵守Git分支使用的原则删除change_inf分支后，结构将会是这样的

    * 882e00a - (HEAD -> master)完成修改资料的功能
    |
    * c7d31a2 - 写完了修改资料的后台
    |
    * 2fd639f - 写完了修改资料的页面
    |
    * eff7c11 - 完成修改密码的功能
    | 
    * 4e40742 - 构架目录
    |
    * 34309d9 - 创建项目

当项目变大，结构会更加的复杂，找到上一个稳定上线版本几乎是不可能的事情。

这时候就需要打标签了。每当有某个功能分支合并进master分支，我们会这个合并生成的commit打一个标签，如v1.1，一方面来标识版本，另一方面可以标识它是由其他分支合并生成的稳定的“成品”commit，而不是那些“原材料”commit。

    * 882e00a - (HEAD -> master, tag: v1.2)完成修改资料的功能
    |
    * c7d31a2 - 写完了修改资料的后台
    |
    * 2fd639f - 写完了修改资料的页面
    |
    * eff7c11 - (tag: v1.1)完成修改密码的功能
    | 
    * 4e40742 - (tag: v1.0)构架目录
    |
    * 34309d9 - (tag: v0.0)创建项目

有了标签，结构是不是就容易分辨的多了？

## 整理分支上的提交（commit） ##

有时候写项目过程中并不是那么的如意，我们可能会产生很多无意义的commit，如果合并进主分支再删除功能分支，会遗留一堆无意义的commit，这样也违背了“干净”的原则，比如下面的结构：


    *   882e00a - (HEAD -> master)完成修改资料的功能
    |\
    | * 4b8ad32 - (change_inf)刚刚没修好，再修一次
    | |
    | * bd1a340 - 修复后台的字段验证小bug
    | |
    | * 2fd639f - 调整了脚部分字体颜色
    | |
    | * c7d31a2 - 写完了修改资料的后台
    | |
    | * cba5826 - 修复导航栏的小bug
    | |
    | * 870b6a8 - 写完了修改资料的页面
    |/
    * 4e40742 - 构架目录
    |
    * 34309d9 - 创建项目

可以毫不夸张的说，这个结构如果删除change_inf分支把master分支推要远程仓库，项目负责人一定会打死推送者。除非他请项目组的人吃烧烤，如果还要打，那就再请一顿。

那么如何避免破费（请吃烧烤）呢？这时候我们就要使用一个危险的命令

    git rebase -i

为什么说危险呢，因为这个命令如果使用不当有可能会毁掉你整个版本库，所以使用过程中一定要多加小心。

这个命令大致功能是允许你重新整理commit，比如我们切换到change_inf执行

    git rebase -i 34309d9
    
将会进入一种特殊的状态，具体这种状态的用法网上已有较为成熟的资料，这里就不再赘述

在开发者阅读其他网站的关于交互式变基（rebase）资料的时候，注意不要使用

    git rebase -i [分支名]
    
要使用

    git rebase -i [commit_id]

这样测试就会相对轻松一些，变基分支名我们会在后面的章节来详细探讨使用。


## 总结 ##

所谓干净，其实应该是指没有无意义的commit，而不是只commit的个数。相反，master分支的commit数量大部分情况下是所有分支中最多的。